/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tliangso <earth78203@gmail.com>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/10 13:02:26 by tliangso          #+#    #+#             */
/*   Updated: 2023/02/10 14:00:40 by tliangso         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef VECTOR_HPP
# define VECTOR_HPP

# include <iostream>
# include <memory>
# include <cstring>
# include <cstddef>

# include "iterator.hpp"
# include "utils/algorithm.hpp"
# include "utils/type_traits.hpp"
# include "utils/utility.hpp"

namespace ft
{
	template <class T, class Alloc = std::allocator<T> >
	class vector
	{
		public:
			typedef T 											value_type;
			typedef Alloc										allocator_type;
			typedef typename allocator_type::size_type			size_type;
			typedef typename allocator_type::difference_type	difference_type;
			typedef typename allocator_type::reference			reference;
			typedef typename allocator_type::const_reference	const_reference;
			typedef typename allocator_type::pointer			pointer;
			typedef typename allocator_type::const_pointer		const_pointer;

		public:
			typedef typename ft::base_iterator<pointer>				iterator;
			typedef typename ft::base_iterator<const_pointer>		const_iterator;
			typedef typename ft::reverse_iterator<iterator>			reverse_iterator;
			typedef typename ft::reverse_iterator<const_iterator>	const_reverse_iterator;

		public:
			explicit vector(const allocator_type& alloc = allocator_type())
			:  _start(u_nullptr), _finish(u_nullptr), _end_of_storage(u_nullptr), _alloc(alloc) {}

			explicit vector(size_type n, const value_type& value = value_type(), const allocator_type& alloc = allocator_type())
			: _alloc(alloc)
			{
				_start = _alloc.allocate(n);
				_end_of_storage = _start + n;
				_finish = std::uninitialized_fill_n(_start, n, value);
			}

			template <class InputIterator>
			vector(InputIterator first, InputIterator last, const allocator_type& alloc = allocator_type(), typename ft::enable_if<!ft::is_integral<InputIterator>::value>::type* = 0) : _alloc(alloc)
			{
				typedef typename ft::iterator_traits<InputIterator>::iterator_category iterator_category;
				_fill_initialize(first, last, iterator_category());
			}

			vector(const vector& x) : _alloc(x._alloc)
			{
				_start = _alloc.allocate(x.size());
				_end_of_storage = _start + x.size();
				_finish = std::uninitialized_copy(x.begin(), x.end(), _start);
			}

			~vector()
			{
				_destroy(_start, _finish);
				_dealocate();
			}

			vector& operator=(const vector& x)
			{
				if (this != &x)
				{
					const size_type xlen = x.size();
					if (xlen > capacity())
					{
						iterator tmp = _alloc.allocate(xlen);
						std::uninitialized_copy(x.begin(), x.end(), tmp);
						_destroy(_start, _finish);
						_dealocate();
						_start = tmp;
						_end_of_storage = _start + xlen;
					}
					else if (size() >= xlen)
					{
						iterator i = std::copy(x.begin(), x.end(), begin());
						_destroy(i, _finish);
					}
					else
					{
						std::copy(x.begin(), x.begin() + size(), _start);
						std::uninitialized_copy(x.begin() + size(), x.end(), _finish);
					}
					_finish = _start + xlen;
				}
				return *this;
			}

			iterator begin()
			{
				return _start;
			}

			const_iterator begin() const
			{
				return _start;
			}

			iterator end()
			{
				return _finish;
			}

			const_iterator end() const
			{
				return _finish;
			}

			reverse_iterator rbegin()
			{
				return reverse_iterator(end());
			}

			const_reverse_iterator rbegin() const
			{
				return const_reverse_iterator(end());
			}

			reverse_iterator rend()
			{
				return reverse_iterator(begin());
			}

			const_reverse_iterator rend() const
			{
				return const_reverse_iterator(begin());
			}

			size_type size() const
			{
				return _finish - _start;
			}

			size_type max_size() const
			{
				return _alloc.max_size();
			}

			void resize(size_type n, value_type val = value_type())
			{
				if (n < size())
					erase(begin() + n, end());
				else
					insert(end(), n - size(), val);
			}

			size_type capacity() const
			{
				return _end_of_storage - _start;
			}

			bool empty() const
			{
				return _start == _finish;
			}

			void reserve(size_type n)
			{
				if (capacity() < n)
				{
					const size_type old_size = size();
					iterator tmp = _alloc.allocate(n);
					std::uninitialized_copy(begin(), end(), tmp);
					_destroy(_start, _finish);
					_dealocate();
					_start = tmp;
					_finish = _start + old_size;
					_end_of_storage = _start + n;
				}
			}

			reference operator[](size_type n)
			{
				return _start[n];
			}

			const_reference operator[](size_type n) const
			{
				return _start[n];
			}

			reference at(size_type n)
			{
				if (n >= size())
					throw std::out_of_range("ft::vector::at");
				return _start[n];
			}

			const_reference at(size_type n) const
			{
				if (n >= size())
					throw std::out_of_range("ft::vector::at");
				return _start[n];
			}

			reference front()
			{
				return *_start;
			}

			const_reference front() const
			{
				return *_start;
			}

			reference back()
			{
				return *(_finish - 1);
			}

			const_reference back() const
			{
				return *(_finish - 1);
			}

			template <class InputIterator>
			void assign(InputIterator first, InputIterator last, typename ft::enable_if<!ft::is_integral<InputIterator>::value>::type* = 0)
			{
				clear();
				for (; first != last; ++first)
					push_back(*first);
			}

			void assign(size_type n, const value_type& val)
			{
				_fill_assign(n, val);
			}

			void push_back(const value_type& val)
			{
				if (_finish != _end_of_storage)
				{
					_alloc.construct(&(*_finish), val);
					++_finish;
				}
				else
					_insert_aux(end(), val);
			}

			void pop_back()
			{
				--_finish;
				_alloc.destroy(_finish);
			}

			iterator insert(iterator position, const value_type& val)
			{
				if (position == end())
				{
					push_back(val);
					return end() - 1;
				}
				else
					return _insert_aux(position, val);
			}

			void insert(iterator position, size_type n, const value_type& val)
			{
				_fill_insert(position, n, val);
			}

			template <class InputIterator>
			void insert(iterator position, InputIterator first, InputIterator last, typename ft::enable_if<!ft::is_integral<InputIterator>::value>::type* = 0)
			{
				typedef typename ft::iterator_traits<InputIterator>::iterator_category iterator_category;
				_insert_dispatch(position, first, last, iterator_category());
			}

			iterator erase(iterator position)
			{
				if (position + 1 != end())
					std::copy(position + 1, end(), position);
				--_finish;
				_alloc.destroy(_finish);
				return position;
			}

			iterator erase(iterator first, iterator last)
			{
				iterator i = std::copy(last, end(), first);
				_destroy(i, end());
				_finish = _finish - (last - first);
				return first;
			}

			void swap(vector& x)
			{
				std::swap(_start, x._start);
				std::swap(_finish, x._finish);
				std::swap(_end_of_storage, x._end_of_storage);
			}

			void clear()
			{
				_destroy(_start, _finish);
				_finish = _start;
			}

		private:
			iterator _start;
			iterator _finish;
			iterator _end_of_storage;
			allocator_type _alloc;

			void _destroy(iterator first, iterator last)
			{
				for (; first != last; ++first)
					_alloc.destroy(&(*first));
			}

			void _dealocate()
			{
				// std::cout << "_start.base() = " << _start << "|" << std::endl;
				if (_start.base() != 0)
					_alloc.deallocate(&(*_start), capacity());
			}

			void _fill_assign(size_type n, const value_type& val)
			{
				clear();
				// if (n > capacity())
				// {
				// 	vector tmp(n, val, _alloc);
				// 	tmp._finish = std::uninitialized_fill_n(tmp._start, n, val);
				// 	swap(tmp);
				// }
				// else if (size() >= n)
				// {
				// 	iterator i = std::fill_n(begin(), n, val);
				// 	_destroy(i, end());
				// 	_finish = _start + n;
				// }
				// else
				// {
				// 	std::fill(begin(), end(), val);
				// 	_finish = std::uninitialized_fill_n(_finish, n - size(), val);
				// }

				if (n <= capacity())
					_finish = std::uninitialized_fill_n(_start, n, val);
				else
				{
					_dealocate();
					_fill_initialize(n, val);
				}
			}

			void _fill_initialize(size_type n, const value_type& val)
			{
				_start = _alloc.allocate(n);
				_end_of_storage = _start + n;
				_finish = std::uninitialized_fill_n(_start, n, val);
			}

			template <class InputIterator>
			void _range_initialize(InputIterator first, InputIterator last)
			{
				_start = _alloc.allocate(last - first);
				_end_of_storage = _start + (last - first);
				_finish = std::uninitialized_copy(first, last, _start);
			}

			iterator _insert_aux(iterator position, const value_type& val)
			{
				if (_finish != _end_of_storage)
				{
					_alloc.construct(&(*_finish), *(_finish - 1));
					++_finish;
					value_type val_copy = val;
					std::copy_backward(position, _finish - 2, _finish - 1);
					*position = val_copy;
					return position;
				}
				else
				{
					const size_type old_size = size();
					const size_type len = old_size != 0 ? 2 * old_size : 1;
					iterator tmp = iterator(_alloc.allocate(len));
					iterator new_start = tmp;
					iterator new_finish = new_start;
					try
					{
						new_finish = std::uninitialized_copy(_start, position, new_start);
						_alloc.construct(new_finish.base(), val);
						++new_finish;
						new_finish = std::uninitialized_copy(position, _finish, new_finish);
					}
					catch (...)
					{
						_destroy(new_start, new_finish);
						_alloc.deallocate(new_start.base(), len);
						throw;
					}
					_destroy(begin(), end());
					_alloc.deallocate(&(*_start), _end_of_storage - _start);
					_start = new_start;
					_finish = new_finish;
					_end_of_storage = new_start + len;
					return _start + old_size;
				}
			}

			void _fill_insert(iterator position, size_type n, const value_type& val)
			{
				if (n != 0)
				{
					if (static_cast<size_type>(_end_of_storage - _finish) >= n)
					{
						value_type val_copy = val;
						const size_type elems_after = _finish - position;
						iterator old_finish = _finish;
						if (elems_after > n)
						{
							std::uninitialized_copy(_finish - n, _finish, _finish);
							_finish += n;
							std::copy_backward(position, old_finish - n, old_finish);
							std::fill(position, position + n, val_copy);
						}
						else
						{
							std::uninitialized_fill_n(_finish, n - elems_after, val_copy);
							_finish += n - elems_after;
							std::uninitialized_copy(position, old_finish, _finish);
							_finish += elems_after;
							std::fill(position, old_finish, val_copy);
						}
					}
					else
					{
						const size_type old_size = size();
						const size_type len = old_size + std::max(old_size, n);
						iterator tmp = _alloc.allocate(len);
						iterator new_start = tmp;
						iterator new_finish = new_start;
						try
						{
							new_finish = std::uninitialized_copy(_start, position, new_start);
							new_finish = std::uninitialized_fill_n(new_finish, n, val);
							new_finish = std::uninitialized_copy(position, _finish, new_finish);
						}
						catch (...)
						{
							_destroy(new_start, new_finish);
							_alloc.deallocate(new_start, len);
							throw;
						}
						_destroy(begin(), end());
						_alloc.deallocate(_start, _end_of_storage - _start);
						_start = new_start;
						_finish = new_finish;
						_end_of_storage = new_start + len;
					}
				}
			}

			template <class InputIterator>
			void _range_insert(iterator position, InputIterator first, InputIterator last, std::input_iterator_tag)
			{
				for (; first != last; ++first)
				{
					position = insert(position, *first);
					++position;
				}
			}

			template <class ForwardIterator>
			void _range_insert(iterator position, ForwardIterator first, ForwardIterator last, std::forward_iterator_tag)
			{
				if (first != last)
				{
					size_type n = std::distance(first, last);
					if (static_cast<size_type>(_end_of_storage - _finish) >= n)
					{
						const size_type elems_after = _finish - position;
						iterator old_finish = _finish;
						if (elems_after > n)
						{
							std::uninitialized_copy(_finish - n, _finish, _finish);
							_finish += n;
							std::copy_backward(position, old_finish - n, old_finish);
							std::copy(first, last, position);
						}
						else
						{
							ForwardIterator mid = first;
							std::advance(mid, elems_after);
							std::uninitialized_copy(mid, last, _finish);
							_finish += n - elems_after;
							std::uninitialized_copy(position, old_finish, _finish);
							_finish += elems_after;
							std::copy(first, mid, position);
						}
					}
					else
					{
						const size_type old_size = size();
						const size_type len = old_size + std::max(old_size, n);
						iterator tmp = _alloc.allocate(len);
						iterator new_start = tmp;
						iterator new_finish = new_start;
						try
						{
							new_finish = std::uninitialized_copy(_start, position, new_start);
							new_finish = std::uninitialized_copy(first, last, new_finish);
							new_finish = std::uninitialized_copy(position, _finish, new_finish);
						}
						catch (...)
						{
							_destroy(new_start, new_finish);
							_alloc.deallocate(new_start, len);
							throw;
						}
						_destroy(begin(), end());
						_alloc.deallocate(_start, _end_of_storage - _start);
						_start = new_start;
						_finish = new_finish;
						_end_of_storage = new_start + len;
					}
				}
			}

	}; // class vector

} // namespace ft

#endif // VECTOR_HPP
